import {pipe} from 'fp-ts/lib/function';
import * as RA from 'fp-ts/ReadonlyArray';
import * as RR from 'fp-ts/ReadonlyRecord';
import * as S from 'fp-ts/string';
import * as TE from 'fp-ts/TaskEither';
import * as E from 'fp-ts/Either';
import {sequenceS} from 'fp-ts/lib/Apply';

import {Dependencies} from '../dependencies';
import {Logger} from 'pino';
import {EventOfType} from '../types/domain-event';
import {Ord, contramap} from 'fp-ts/lib/Ord';
import {record} from 'fp-ts';
import {FailureWithStatus, failureWithStatus} from '../types/failureWithStatus';
import {sheets_v4} from 'googleapis';
import {StatusCodes} from 'http-status-codes';

type QzEvent = EventOfType<'EquipmentTrainingQuizResult'>;
type RegEvent = EventOfType<'EquipmentTrainingSheetRegistered'>;

// Take the last element in the array for each key generated by fn.
// This probably already exists as a function in fp-ts but the docs suck... (or maybe my searching does...)
const lastBy = <K extends string, E>(fn: (a: E) => K) =>
  RA.reduce<E, Record<K, E>>({} as Record<K, E>, (a, e) => {
    a[fn(e)] = e;
    return a;
  });

const accumBy =
  <K extends string, E>(fn: (a: E) => K) =>
  (arr: ReadonlyArray<E>) =>
    pipe(
      arr,
      RA.reduce<E, Record<K, E[]>>({} as Record<K, E[]>, (a, e) => {
        // break immutability in favour of performance & simplicity.
        const key = fn(e);
        if (a[key]) {
          a[key].push(e);
        } else {
          a[key] = [e];
        }
        return a;
      }),
      record.map(RA.fromArray),
      RR.fromRecord
    );

const byEquipmentId: Ord<RegEvent> = pipe(
  S.Ord,
  contramap((e: RegEvent) => e.equipmentId)
);

const getTrainingSheets = (events: ReadonlyArray<RegEvent>) =>
  pipe(
    events,
    RA.sortBy([byEquipmentId]),
    lastBy(event => event.equipmentId)
  );

const getPreviousQuizResultsByEquipment = accumBy<string, QzEvent>(
  e => e.equipmentId
);

// const extractColumnNames = (
//   sheet: sheets_v4.Schema$Sheet
// ): O.Option<string[]> => {
//   if (!sheet.data || sheet.data.length < 1) {
//     return O.none;
//   }
//   if (!sheet.data[0].rowData || sheet.data[0].rowData.length < 1) {
//     return O.none;
//   }
//   if (
//     !sheet.data[0].rowData[0].values ||
//     sheet.data[0].rowData[0].values.length < 1
//   ) {
//     return O.none;
//   }
//   return O.some(
//     sheet.data[0].rowData[0].values.map(cd => cd.formattedValue ?? '')
//   );
// };

const extractGoogleSheetData =
  (
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _existingQuizResults: ReadonlyArray<QzEvent>
  ) =>
  (
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _spreadsheet: sheets_v4.Schema$Spreadsheet
  ): TE.TaskEither<FailureWithStatus, ReadonlyArray<QzEvent>> => {
    // Initially
    // - Only handle a single sheet per-page.
    // - Assume the column names are the first row.

    // TODO
    return TE.right(RA.empty);
  };

const processForEquipment = (
  logger: Logger,
  deps: Dependencies,
  regEvent: RegEvent,
  existingQuizResults: ReadonlyArray<QzEvent>
): TE.TaskEither<FailureWithStatus, ReadonlyArray<QzEvent>> => {
  logger.info(`Scanning training sheet ${regEvent.trainingSheetId}...`);
  // TODO - Check global rate limit. -> Maybe this should also be an event?

  return pipe(
    deps.pullGoogleSheetData(logger, regEvent.trainingSheetId),
    TE.mapLeft(
      failureWithStatus(
        'Failed to pull google sheet data',
        StatusCodes.INTERNAL_SERVER_ERROR
      )
    ),
    TE.chain(extractGoogleSheetData(existingQuizResults))
  );
};

const process =
  (logger: Logger, deps: Dependencies) =>
  (
    sheetRegEvents: ReadonlyArray<RegEvent>,
    existingQuizResultEvents: ReadonlyArray<QzEvent>
  ): TE.TaskEither<FailureWithStatus, ReadonlyArray<QzEvent>> => {
    const trainingSheets = getTrainingSheets(sheetRegEvents);
    const previousQuizResults = getPreviousQuizResultsByEquipment(
      existingQuizResultEvents
    );
    return pipe(
      Object.entries(trainingSheets),
      RA.map(([equipmentId, sheet]) =>
        processForEquipment(
          logger.child({equipment: equipmentId}),
          deps,
          sheet,
          previousQuizResults[sheet.trainingSheetId] ?? RA.empty
        )
      ),
      TE.sequenceArray,
      TE.chain(entries => TE.right(RA.flatten(entries)))
    );
  };

export const run = async (
  deps: Dependencies,
  logger: Logger
): Promise<void> => {
  const newEvents = await pipe(
    {
      equipmentEvents:
        deps.getAllEventsByType<'EquipmentTrainingSheetRegistered'>(
          'EquipmentTrainingSheetRegistered'
        ),
      equipmentQuizEvents:
        deps.getAllEventsByType<'EquipmentTrainingQuizResult'>(
          'EquipmentTrainingQuizResult'
        ),
    },
    sequenceS(TE.ApplySeq),
    TE.chain(({equipmentEvents, equipmentQuizEvents}) =>
      process(logger, deps)(equipmentEvents, equipmentQuizEvents)
    )
  )();

  if (E.isLeft(newEvents)) {
    logger.error(newEvents.left, 'Failed to get training quiz results');
    return;
  }

  for (const newEvent of newEvents.right) {
    pipe(
      await deps.commitEvent(
        {
          type: 'EquipmentTrainingQuizResult',
          id: newEvent.id,
        },
        -1
      )(newEvent)(),
      E.fold(
        (err: FailureWithStatus) => logger.error(err),
        success => logger.debug(success)
      )
    );
  }
};

const runLogged = async (deps: Dependencies, logger: Logger) => {
  const start = performance.now();
  try {
    await run(deps, logger);
    logger.info(
      `Took ${Math.round(
        performance.now() - start
      )}ms to run training sheets worker job`
    );
  } catch (err) {
    logger.error(err, 'Unhandled error in training sheets worker');
  }
};

// I generally don't like this way of doing things and prefer an await loop
// but trying a different approach.
export const runForever = (deps: Dependencies) => {
  const logger = deps.logger.child({section: 'training-sheets-worker'});
  void runLogged(deps, logger);
  return setInterval(
    // TODO - Handle run still going when next run scheduled.
    () => void runLogged(deps, logger),
    30 * 60 * 1000
  );
};
