import {pipe} from 'fp-ts/lib/function';
import * as E from 'fp-ts/Either';
import * as RA from 'fp-ts/ReadonlyArray';
import * as RR from 'fp-ts/ReadonlyRecord';
import * as S from 'fp-ts/string';
import {Dependencies} from '../dependencies';
import {Logger} from 'pino';
import {EventOfType} from '../types/domain-event';
import {Ord, contramap} from 'fp-ts/lib/Ord';
import {record} from 'fp-ts';
import {notImplementedA} from '../not_implemented';

type QzEvent = EventOfType<'EquipmentTrainingQuizResult'>;
type RegEvent = EventOfType<'EquipmentTrainingSheetRegistered'>;

// type EquipmentTrainingQuizResult = {
//   type: 'EquipmentTrainingQuizResult';
//   id: UUID;
// };

// Take the last element in the array for each key generated by fn.
// This probably already exists as a function in fp-ts but the docs suck... (or maybe my searching does...)
const lastBy = <K extends string, E>(fn: (a: E) => K) =>
  RA.reduce<E, Record<K, E>>({} as Record<K, E>, (a, e) => {
    a[fn(e)] = e;
    return a;
  });

const accumBy =
  <K extends string, E>(fn: (a: E) => K) =>
  (arr: ReadonlyArray<E>) =>
    pipe(
      arr,
      RA.reduce<E, Record<K, E[]>>({} as Record<K, E[]>, (a, e) => {
        // break immutability in favour of performance & simplicity.
        const key = fn(e);
        if (a[key]) {
          a[key].push(e);
        } else {
          a[key] = [e];
        }
        return a;
      }),
      record.map(RA.fromArray),
      RR.fromRecord
    );

const byEquipmentId: Ord<RegEvent> = pipe(
  S.Ord,
  contramap((e: RegEvent) => e.equipmentId)
);

const getTrainingSheets = (events: ReadonlyArray<RegEvent>) =>
  pipe(
    events,
    RA.sortBy([byEquipmentId]),
    lastBy(event => event.equipmentId)
  );

const getPreviousQuizResultsByEquipment = accumBy<string, QzEvent>(
  e => e.equipmentId
);

// TODO - Use functional code like the rest of the code base.

// const extractGoogleSheetData = (data: sheets_v4.Schema$Spreadsheet) => {
//   return notImplemented([data]);
// };

const processForEquipment = async (
  logger: Logger,
  deps: Dependencies,
  regEvent: RegEvent,
  existingQuizResults: ReadonlyArray<QzEvent>
): Promise<[string, ReadonlyArray<QzEvent>]> => {
  logger.info(`Scanning training sheet ${regEvent.trainingSheetId}...`);
  // TODO - Check global rate limit. -> Maybe this should also be an event?

  const data = await deps.pullGoogleSheetData(
    logger,
    regEvent.trainingSheetId
  )();
  await notImplementedA([data, existingQuizResults]);
  // const extracted = extractGoogleSheetData(data);

  // logger.info('Received google sheet data');

  // logger.info(`Finished scanning ${regEvent.trainingSheetId}`);
  return [regEvent.equipmentId, RA.empty];
};

export const process = async (
  logger: Logger,
  deps: Dependencies,
  sheetRegEvents: ReadonlyArray<RegEvent>,
  existingQuizResultEvents: ReadonlyArray<QzEvent>
): Promise<Record<string, ReadonlyArray<QzEvent>>> => {
  const trainingSheets = getTrainingSheets(sheetRegEvents);
  const previousQuizResults = getPreviousQuizResultsByEquipment(
    existingQuizResultEvents
  );

  const jobs = [];
  for (const [equipmentId, sheet] of Object.entries(trainingSheets)) {
    jobs.push(
      processForEquipment(
        logger.child({equipment: equipmentId}),
        deps,
        sheet,
        previousQuizResults[sheet.trainingSheetId] ?? RA.empty
      )
    );
  }

  const results = await Promise.all(jobs);
  return results.reduce(
    (a, c) => {
      a[c[0]] = c[1];
      return a;
    },
    {} as Record<string, ReadonlyArray<QzEvent>>
  );
};

const run = async (deps: Dependencies, logger: Logger): Promise<void> => {
  const equipmentEvents =
    await deps.getAllEventsByType<'EquipmentTrainingSheetRegistered'>(
      'EquipmentTrainingSheetRegistered'
    )();
  const equipmentQuizEvents =
    await deps.getAllEventsByType<'EquipmentTrainingQuizResult'>(
      'EquipmentTrainingQuizResult'
    )();
  if (E.isLeft(equipmentEvents)) {
    logger.error(equipmentEvents.left, 'Skipping training sheet update');
    // TODO - Monitoring.
    return;
  }

  if (E.isLeft(equipmentQuizEvents)) {
    logger.error(equipmentQuizEvents.left, 'Skipping training sheet update');
    // TODO - Monitoring.
    return;
  }

  const result = await process(
    logger,
    deps,
    equipmentEvents.right,
    equipmentQuizEvents.right
  );
  for (const newEvents of Object.values(result)) {
    // TODO commitEvent should support checking no existing resource.
    // TODO commitEvent should support multi-resource commit.
    for (const newEvent of newEvents) {
      await deps.commitEvent(
        {
          type: 'EquipmentTrainingQuizResult',
          id: newEvent.id,
        },
        -1
      )(newEvent)();
    }
  }
};

export const runForever = (deps: Dependencies) => {
  const logger = deps.logger.child({section: 'training-sheets-worker'});
  run(deps, logger).catch(err =>
    logger.error(err, 'Unhandled error in training sheets worker')
  );
  return setInterval(
    // TODO - Handle run still going when next run scheduled.
    () => {
      const start = performance.now();
      run(deps, logger)
        .then(() => {
          logger.info(
            `Took ${Math.round(
              performance.now() - start
            )}ms to run training sheets worker job`
          );
        })
        .catch(err =>
          logger.error(err, 'Unhandled error in training sheets worker')
        );
    },
    30 * 60 * 1000
  );
};
